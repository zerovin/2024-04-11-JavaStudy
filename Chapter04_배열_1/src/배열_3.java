/*
 *	배열 선언
 *	1. 선언과 동시에 초기화
 *	   int[] arr={10,20,30,40,50} => 사용빈도 거의 없음
 *	   => int 5개의 공간을 만들어준다 갯수확인 => 데이터형 확인 => 연속적으로 메모리 만듦
 *	      ------------------------------------
 *	          10  |  20  |  30  |  40  |  50  
 *	      |------------------------------------
 *	      | arr[0] arr[1] arr[2] arr[3] arr[4]  ===> 연속적인 인덱스값 = 첨자
 *	    0x100(배열의 시작점)
 *	       arr=0x100 => 첫번째 값
 *	       0x100로부터 두번째 값 => arr[1]
 *	       arr[1]=200 => 변경 20->200
 *	      ------- 일반 변수와 동일하게 취급 => 값 변경, 출력
 *
 *	   String[]에서는 값을 설정하고 사용
 *	2. 선언 후 초기값
 *	   데이터형[] 배열명; => 권장사항
 *	            └ 변수의 식별자와 동일
 *	   데이터형 배열명[]; => C언어
 *		└ 배열에 저장되는 데이터의 종류(어떤 데이터를 저장할 지)
 *	      정수 int[]
 *	      실수 double[]
 *	      문자열 String[]
 *	      ...
 *	      문자 char[]
 *	   [] - 같은 데이터를 모아서 관리 => 배열 기호
 *	   배열명 - 실제값을 가지고 있는 것이 아닌 실제 데이터가 저장되어있는 위치의 주소
 *	          주소를 참조해서 여러개의 데이터 관리 => 참조 변수
 *	3. 기본값으로 초기화
 *	   데이터형[] 배열명=new 데이터형[갯수]
 *	   int=0 / double=0.0 / boolean=false 값으로 초기화
 *	   갯수 = 배열의 크기
 *	   ex)
 *	      int[] arr=new int[3]; ==> 0 0 0
 *	      double[] arr=new double[3]; ==> 0.0 0.0 0.0
 *	      boolean[] arr=new boolean[3]; ==> false false false
 *
 *	** 변수 = 실제 저장값 => 기본형
 *	** 배열 / 클래스 = 저장된 위치의 메모리 주소값 => 여러개의 데이터 관리 => 참조형
 *	   배열 - 인덱스를 이용해서 데이터를 가지고 온다 , 수정
 *	   클래스 - 인덱스가 없음, 주소 접근 연산자(.) 이용 ex) .equals .length .substring ...
 *
 */
public class 배열_3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr= {10,20,30,40,50};
		System.out.println("arr:"+arr); //[arr:[I@6f2b958e
		/*
		 *	     -----------------------
		 *		    10  20  30  40  50
		 *	    |-----------------------
		 * [I@6f2b958e => 메모리 주소값
		 *
		 */
	}

}
