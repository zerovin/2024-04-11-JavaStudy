package com.sist.main;
/*
 * 	5장
 *	118page 클래스구조
 *	  [접근지정어] [제어어] class ClassName{ => 형식
 *	     접근지정어 - public
 *	               한개의 파일에 클래스를 여러개 만드는 경우 public은 한번만 사용가능
 *	               가급적 한개의 자바파일에 여러개 클래스 생성 지양
 *	     제어어 - 대부분 default
 *	            static - 공통으로 사용되는 기능 ex)네트워크(client/server)동시사용클래스, 데이터분석
 *	            abstract - 추상클래스, 선언만 된 메소드, 미완성된 클래스, 메모리 할당을 할 수 없다
 *	                       상속 받은 후 구현 후 사용(상속, 오버라이딩)
 *	            final - 종단클래스, 확장 할 수 없는 클래스=상속불가(사용빈도 거의 없음)
 *	                    ex)String, System, Math, StringBuffer, Wrapper
 *	     변수(멤버변수) - 지정해서 관리할 데이터를 메모리에 저장할 목적, 프로그램 종료시까지 메모리 유지
 *	                  따로 저장 공간 - 인스턴스 변수** => new를 이용해서 메모리 공간을 만들고 저장 후 사용
 *	                  1개만 저장 공간 - 정적 변수 => static
 *	                  변수로 사용할 수 있는 것 - 기본형(정수,실수,논리,문자)
 *	                                       배열
 *	                                       클래스 => 포함클래스, 데이터형(사용자 정의)
 *	                                         ex)String, Movie[] movies=new Movie[1938]
 *	                  변수는 외부에서(다른 클래스에서) 변경할 수 없게 보호
 *	                    => 캡슐화 : 변수는 은닉화 private, 메소드를 통해서 접근가능 getter/setter
 *	                  1.출력화면을 보고 데이터 추출 (안보이는 데이터 주의, 클래스의 변수, 구분자 반드시 포함)
 *	                    ex)게시물번호, 영화번호... 배열의 인덱스와 매칭
 *	                  2.캡슐화 => 시큐어 코딩의 기본, getter/setter 자동생성=>lombok
 *	     생성자 - 초기화, 배열의 값을 채운다 ex)파일읽기, 오라클 연결
 *	            클래스 블록은 선언(변수선언, 메소드선언)만 가능 ex)int a; public void display();
 *	            초기화 블록에서 구현 후 초기화
 *	            인스턴스 변수에 대한 초기화 - 생성자, 인스턴스 사용을 위해서는 생성자 반드시 호출 - 클래스 객체명=new 생성자(), 객체명.변수명
 *	            정적 변수 static 변수 초기화 - static{}, 생성자 호출없이도 사용가능 - 클래스.변수명
 *	            접근지정어 public - 다른 클래스에서 사용가능
 *	            클래스명과 동일
 *	            리턴형 없음
 *	            여러개 생성가능 - 같은 메소드명으로 여러개 생성 == 오버로딩
 *	            모든 클래스에 한개이상 존재 - 생략시 컴파일러에서 매개변수없는 디폴트생성자 자동추가
 *	     메소드 - 멤버변수를 활용하는 기능 제작 ex)목록출력, 상세보기, 예약, 추천, 결제, 검색...
 *	            결과값 - 리턴형, 하나만 사용가능, 데이터가 많을시 배열/클래스
 *	            사용자 요청값 - 매개변수, 여러개 사용가능, 3개초과시 배열/클래스
 *	            형식 - [접근지정어] [제어어] 리턴형 메소드명(매개변수리스트){ => 선언부
 *	                      구현부
 *	                      return 전송할 값; => 리턴형과 같은 데이터형
 *	                                         void일 경우 return 생략가능, 메소드 자체처리(데이터베이스 수정,추가,삭제)
 *	                  }
 *	                  접근지정어 - public : 메소드는 다른 클래스와 연결할 때 사용 => 공개
 *	                  제어어 - default : 인스턴스 메소드*** => 따로 저장
 *	                         static : 공통으로 사용되는 기능 ex)한글변환,암호화,복호화,정렬...
 *	                         abstract : 구현이 안된 메소드 => 프로그램에 맞게 구현 ex)버튼, 마우스, 키보드 클릭입력
 *	                                    메소드 호출은 가능 구현은 프로그램에 맞게 => 설계만 하는 기능
 *	                                    => 추상클래스/인터페이스 => 요구사항분석
 *	            기능별로 나눠서 작업 => 구조적 프로그램
 *	            문장 => 단락을 나눠서 처리
 *	            반복적인 기능이 많은 경우 사용
 *	            다른 클래스와 연결
 *	            재사용 가능, 수정/추가 => 클래스의 핵심 ex)메뉴, 버튼, 입력창, 마우스클릭...
 *	            호출시마다 처음부터 시작
 *	            public class A{
 *	               public void display(){}
 *	               public int aaa(){
 *	                  return 10;
 *	               }
 *	               public A[] bbb(int page){
 *	                  return new A[];
 *	               }
 *	            }
 *	            A aa=new A();
 *	            aa.display() => void
 *	            int a=aa.aaa();
 *	            A[] arr=aa.bbb(1);
 *    }
 *    
 *	122page 객체생성
 *	  1.클래스 - 설계
 *	    public class A{
 *        int a;
 *        public void disp(){}
 *	    }
 *	  2.메모리에 저장
 *      A aa=new A();
 *      aa => 메모리주소 => a, disp() 접근시 . 사용
 *      new => 설계된 데이터를 모아주는 메모리 생성, 데이터+메소드
 *      A() => 변수에 대한 값을 대입, 생성자는 .으로 사용하는 것이 아니라 new 생성자()
 *      ---aa---
 *       0x100 => new의 역할 => 동적메모리 할당
 *      --------   0x100 ----------
 *                       ----a-----
 *                           0 => 생성자가 하는 역할
 *                       ----------
 *                       --disp()--
 *                       
 *                       ----------
 *                       ----------
 *	  3.객체활용(변수호출, 메소드호출)
 *      클래스명 객체명=new 생성자()
 *      객체명.변수명 / 객체명.메소드명
 *	123page 객체사용
 *    설계 => 저장 => 활용 => 메모리해제
 *    class => new => . => null(주소값이 없는 상태) ===> GC(가비지컬렉션) 대상
 *    ---------------------------------객체의 생명주기 
 *	127page 접근지정어
 *    클래스와 클래스를 연결할 때 사용
 *    변수 => private : 자신의 클래스에서만 사용가능, 정보는 private ex)영화,맛집,회원정보...
 *                     private을 사용하지 않는 경우 => public ex)JButton, JTextField.. 정보가 아닌 클래스
 *           [접근지정어] 데이터형 변수명
 *           접근지정어 - 거의 private으로 설정 => 캡슐화 => 필요시 접근가능 => getter/setter
 *           변수의 기능 2가지 - 메모리 저장 setter, 메모리의 값을 가지고 온다 getter
 *    클래스 - [접근지정어] class ClassName{}
 *           접근지정어 - public
 *    메소드 - [접근지정어] 리턴형 메소드명(매개변수){}
 *           접근지정어 - public
 *    생성자 - [접근지정어] 클래스명(){}
 *           접근지정어 - public
 *    **public - 모든 클래스에서 접근가능
 *      default - 자신의 클래스 / 같은 패키지(폴더)까지만 접근가능
 *      protected - 자신의 클래스 / 같은 패키지(폴더)까지만 접근가능 / 상속을 받은 경우 다른 패키지에서 접근가능
 *    **접근 범위
 *      private < default < protected < public
 *	132page 패키지(폴더) 한번만 사용가능
 *    패키지 - 관련된 클래스를 모아서 관리 => 기능별 분리 => 검색이 쉽게
 *           package 경로명;
 *           패키지명은 숫자시작 불가
 *           키워드 사용금지
 *           com(org).회사명.구분자 ex)오라클연결-dao, 데이터형-vo, 크롤링/OpenApi-manager, 웹전송-service
 *           클래스 찾기가 쉽다
 *           다른 패키지라면 같은 클래스명을 사용할 수 있다
 *	136page import 여러개 사용가능
 *    import - 패키지를 불러오는 경우
 *             1.라이브러리 불러오기
 *             2.사용자 정의 클래스 불러오기
 *	140page 메소드
 *	152page getter/setter
 *	166page 생성자
 *
 *	6장
 *	194page 상속 (웹에서 사용빈도 거의 없)
 *    목적 - 기존의 클래스를 재사용할 때 사용, 수정/추가 가능
 *          사용중인 메소드를 상속받기 때문에 신뢰성이 뛰어남
 *    상속에서 넘겨주는 내용 - 변수 - static 제외(공통으로 사용 가능)
 *                             private 상속가능, 접근불가능 => protected 이용
 *                       메소드
 *                       생성차, 초기화블록 제외
 *    형식 class A extends B
 *        A - 상속을 받는 클래스 : 상속을 받아 기존의 기능 + 추가기능, 확장해서 사용
 *                            서브클래스, 자식클래스, 하위클래스, 파생클래스
 *        B - 상속을 내리는 클래스 : 라이브러리 상속을 주로 받는다
 *                             슈퍼클래스, 부모클래스, 상위클래스, 베이스클래스
 *        상속을 내린 클래스의 소스를 반복할 필요가 없다
 *          상속을 받으면 보이지 않아도 기능이 존재 => 소스가 간결
 *          ex) class A{ ★ ○ ▲ }
 *              class B extends A{ 
 *                 //★ ○ ▲ => 작성하지 않아도 A의 기능 존재 (메모리 저장된 상태)
 *              }
 *              class A{
 *                 int a; => super.a
 *                 void display(){} = super.display()
 *              }
 *              class B extends A{ 
 *                 int c;
 *                 //int a; => this.a
 *                 //void display(){} => this.display()
 *              }
 *              **상속을 받은 클래스는 상속을 내린 클래스의 변수, 메소드에 접근가능
 *                상속을 내린 클래스는 상속을 받은 클래스의 변수, 메소드에 접근불가
 *              **자바의 모든 클래스는 Object 믈래스의 상속을 받는다
 *                Object - 자바에서 가장 큰 데이터형. 어떤 데이터형도 다 받을 수 있음
 *                         ex) Object[] arr={"",10,'A',new A()...} => 다른 데이터형 배열도 가능 
 *                        
 *              B b=new B();
 *              ---b---
 *               0x100
 *              -------   0x100----------
 *                              --super-- => 상위 클래스 메모리 할당, 상속을 내린 클래스 객체
 *                               ---a---
 *                                  0     => b.a
 *                               -------
 *                              display() => b.display()
 *                              ---------
 *                              ---this-- => 하위 클래스 메모리 할당, 자신 클래스의 객체
 *                               ---c---
 *                                  0     => b.c
 *                               -------
 *                              ---------
 *                              ---------
 *	201page 단일상속, 오버라이딩
 *    자바는 단일 상속만 가능
 *     extends 클래스명, 클래스명 => 다중상속 => 불가능
 *     두개를 받는 경우 ex) class A{int a;}
 *                      class B extends A{
 *                         //int a;
 *                         int b;
 *                      }
 *                      class C extends B{
 *                         //int a, int b
 *                         int c;
 *                      }
 *                      => 다중 상속이 없어서 불편한 점이 있 - 단점
 *                         보완 - 인터페이스(다중상속) => 7장
 *                         상속받은 변수, 메소드가 보이지 않기 때문에 변경,수정,추가가 불편 => 가독성저하
 *	207page 상속시 접근제한, 캡슐화가 깨지는 경향
 *    변수 private => 상속 내릴 때 반드시 getter/setter
 *	211page 상속시 생성자
 *    디폴트생성자는 관계없음
 *    매개변수가 있는 생성자가 있는 경우 - 반드시 super()를 이용해서 상위클래스의 생성자를 먼저 호출
 *	215page 키워드 super/this
 *    super - 상속을 내린 클래스의 변수, 메소드 호출
 *    this - 자신의 클래스에 있는 변수, 메소드 호출, 사용
 *           생성자, 멤버메소드에서 사용가능(인스턴스)
 *           static 메소드에서 사용불가 => 멤버가 아님, 인스턴스만 멤버 (공통으로 사용되는 1개의 메모리)
 *                                    사용이 필요한 경우 객체 생성 후 사용
 *    **final이 있는 경우 => 확장이 안되는 메소드, 기능변경(오버라이딩)불가
 *      public final void display(){} => 확장 못하는 메소드
 *      public final class A{} => 상속을 내리지 못함 => 고정
 *      ex) java.lang => final
 *          String, Math, Integer, Double, System...
 *	221page 객체 형변환
 *    묵시적인 형변환 - 왼쪽이 큰 데이터형이면 자동으로 데이터형 변경
 *                  ex) double d=10; => d=10.0
 *                      int i='A'; => i=65
 *                  클래스 크기 확인 - 상속과정이 있어야 크기 비교 가능
 *                    is-a : 상속 - 상속을 내린 클래스가 큼
 *                    has-a : 포함 - 포함을 하고 있는 클래스가 큼
 *                    ex) class A{}
 *                        class B{}
 *                        ------------ A, B 비교불가
 *                        class A{}
 *                        class B extends A{}
 *                        ------------ A > B 크기는 상속을 내리는 클래스가 큼
 *                        객체 생성
 *                        A aa=new A();
 *                        B bb=new B();
 *                        A cc=new B(); => 묵시적 형변환 A>B
 *                        ------------ 상속을 내린 클래스가 상속을 받은 클래스를 이용해서 메모리 할당 가능
 *                        B dd=new A(); => 오류, 작은 데이터형에 큰 데이터형의 값을 넣어서
 *                        
 *                        class 동물{}
 *                        class 사람 extends 동물{}
 *                        is-a
 *                        동물 a=new 동물(); => 동물은 동물이다 O 
 *                        동물 b=new 사람(); => 사람은 동물이다 O
 *                        사람 c=new 사람(); => 사람은 사람이다 O
 *                        사람 d=new 동물(); => 동물은 사람이다 X ==> 형변환
 *                        
 *                        객체 형변환 - 사용자 정의 데이터형에서는 거의 없음 => 라이브러리(리턴형 Object)에서 주로 사용
 *                        A a=new B();
 *                        B b=(B)a;
 *                        
 *                        class A{ display(){} }
 *                        class B{
 *                           A a=new A(); => 포함 has-a
 *                        }
 *                        ------------ A < B 포함을 하고 이는 클래스가 큼
 *                        => 형변환이 없다
 *                        B b=new B();
 *                        b.a.display();
 *                       
 *    강제 형변환 - ex) A a=new B();
 *                   B b=(B)a;
 *                   리플렉션(Spring) => 강제형변환 사용, 자바에서는 사용빈도 적음
 *   
 *  **제어어 - [접근지정어] [제어어] 데이터형 변수
 *           접근지정어 - private(접근거부), default, protected, public(공개)
 *           제어어 - static : 공통적인 => 모든 객체가 동일하게 사용
 *                  final : 마지막인 => 변수-상수, 메소드/클래스-종단
 *                  abstract : 추상적인 => 미완성된
 *  ==============================================
 *  클래스 구성
 *    private - 변수 => 접근 가능 getter/setter
 *    생성자, 메소드 => public
 *  상속
 *    extends 사용 => 모든 데이터, 메소드 상속 
 *    상위클래스 제어시 super
 *    자신클래스 제어시 this
 *    상속을 내리는 클래스는 자신의 변수, 메소드만 사용가능
 *    상속을 받는 클래스는 자신의 변수, 메소드, 상속 내린 클래스의 변수, 메소드 사용가능
 *    객체생성 - 클래스명 객체명=new 생성자()
 *             변수는 클래스명에 따라 결정
 *             메소드는 생성자에 따라 결정
 *             ex) class A{
 *                    int a=10;
 *                    public void display(){}
 *                 }
 *                 class B extends A{
 *                   int a=100; //오버라이딩
 *                   public void display(){}
 *                 }
 *                 A aa=new A();
 *                   aa.a=10; aa.display(){} => A.display()
 *                 B bb=new B();
 *                   bb.a=100; bb.display(){} => B.display()
 *                 A cc=new B(); => 상속이 있는 경우에만 사용가능 / A가 가진 변수, B가 가진 메소드
 *                   cc.a=10; cc.display(){} => B.display() => 오버라이딩된 메소드 호출
 *                 상속이 있는 경우, 클래스와 생성자가 다른 경우 => 변수는 선언된 클래스
 *                                                      메소드는 선언된 생성자
 *  다형성
 *    오버로딩 - 같은 메소드명으로 새로운 기능 추가 == 중복 메소드 정의
 *    오버라이딩 - 같은 메소드명으로 기존의 기능을 수정 == 재정의
 *    
 *                 오버로딩          오버라이딩
 *    상태       같은 클래스내에서     상속 받은 경우    
 *    메소드명         동일             동일
 *    리턴형         관계없음            동일
 *    매개변수    개수,데이터형 다름        동일
 *    접근지정어      관계없음          확장 가능
 *    
 *    **접근지정어 크기
 *      private < default < protected < public
 *  =================================================
 *  객체지향 (OOP Object Oriented Program)
 *  1.데이터보호 - 캡슐화
 *              변수 private 접근금지, 사용시 메소드 이용 읽기-getter 쓰기-setter
 *  2.재사용 - 변경해서 사용 => 상속
 *           있는 그대로 사용 => 포함
 *  3.수정, 추가가 쉽게 - 수정 => 오버라이딩
 *                    추가 -> 오버로딩
 *                    
 *  ==> 형식 5, 6장
 *      구현 연산자(3장), 제어문(4장)
 *	
 * 	7장
 * 	인터페이스
 * 	
 * 	8장
 * 	예외처리 - 직접처리 try~catch
 * 	         간접처리 throws Exception
 * -------------------------------------- 자바 기본형식(문법)
 * 	9장
 * 	라이브러리 - 필요한 메소드 ex)Math-random() ceil()
 * 
 *  오라클 - 사이트에 필요한 데이터 저장, 오라클 연결(자바) => JDBC Java DataBase Connect 
 *  JSP / MVC / Spring / Spring-Boot => 자바기반
 *  HTML / CSS / JavaScript => 브라우저실행 , 자바는 브라우저에서 text, 오라클연결/데이터베이스처리 불가, 화면출력만 가능
 * 
 */
class A{
	//default 생성자는 노상관 => 매개변수가 있는 경우에 super => 극히 드물다 (라이브러리 사용시)
	public A(int a) {
		System.out.println(a);
	}
}
class B extends A{
	public B(int a) {
		super(a); //매개변수가 있는 생성자가 있는 경우 반드시 super() 호출
		// 상위클래스 호출 => 메모리 저장 => 하위클래스 메모리 저장
	}
}
public class MainClass_1{
	public MainClass_1() {
		
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
