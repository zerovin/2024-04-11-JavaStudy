package com.sist.chapter05;
/*
 *	변수 - 한개 저장 메모리 공간
 *	- 데이터형 - 정수 int, long
 *             배열 byte => 네트워크전송, 파일 읽기
 *             실수 double
 *             논리 boolean
 *             문자열 String
 *             사용자 정의 클래스
 *	- 배열 - 같은 데이터형의 변수 여러개를 한개의 이름으로 한번에 저장 => 인덱스 0부터
 *          단점 - 같은 데이터형만 모아서 관리 / 저장개수 지정 => 고정적
 *	- 클래스 - 다른 데이터형 저장가능
 *	         저장 개수를 지정하지 않는다 => 필요한 개수만큼 new 사용
 *	         한개에 대한 정보만 저장 => new 메모리 저장 ex)영화 1개 정보, 음악 1곡 정보...
 *	--------------------------- 연산처리 / 제어문 => 메소드 = 기능처리
 *	프로그램 => 묶음 => 재사용
 *  - 변수 : 배열 / 클래스
 *  - 연산/제어문 : 명령문 => 메소드
 *  - 변수 초기화 : 생성자
 *  
 *  믈래스 구성요소
 *  1.변수(멤버변수)
 *  2.메소드 - 변수에 대한 활용
 *  3.생성자 - 변수에 대한 초기화
 *  
 *  클래스는 한가지 기능 => 프로그램에서는 여러기능 필요 => 클래스 여러개 제작
 *  => 클래스 여러개 연결 => 접근 범위 필요 => 접근지정어
 *  
 *  재사용기법
 *  - 상속 - 변경해서 사용
 *    class A
 *    class B extends A => is-a
 *  - 포함 - 있는 그대로 사용
 *    class C{
 *      A a=new A(); => has-a
 *    }
 *  - 필요시 변경==오버라이딩 / 새로운 기능 추가==오버로딩 => 유지보수
 *  
 *  객체지향의 3대 특성
 *  1.캡슐화 - 데이터보호
 *  2.상속/포함 - 재사용
 *  3.다형성 - 오버라이딩(수정) => modify
 *           오버로딩(중복함수정의-새로운기능추가) => new
 *  4.추상화 - 사물을 단순화 => 클래스의 기본
 *  
 *  클래스의 종류
 *  - 일반 클래스
 *  - 추상 클래스 / 인터페이스 - 미완성 => 개발자가 완성해서 사용 => 설계 ex)게시판 글쓰기,상세,찾기,추가,수정,삭제
 *                         메소드 미구현 => 프로그램에 맞게 구현해서 사용
 *  
 *  예외처리 => 프로그램의 안전성 => 종료하지 않는 프로그램 ex)try-catch
 *  라이브러리 => 조립 => 암기 ex)Math.random() ceil() 컬렉션
 *  
 *  세부적
 *  - 클래스 - 변수 - 인스턴스변수, static 변수, 지역변수 
 * 	       - 메소드 - 인스턴스메소드, static 메소드, 선언만 하는 메소드
 *         - 생성자 - 생성자, 초기화블록 => 동시에 사용X
 *         - 접근지정어 - private(변수), public(나머지)
 *	- 클래스 구성요소 - 무조건 다 사용하는 것은 아니다, 필요한 것만 사용
 *	              **순서 상관X
 *	                권장 사항 : 변수 => 생성자 => 메소드
 *                  class ClassName{
 *                     변수 선언
 *                       [접근지정어] [옵션] 데이터형 변수명
 *                       => 접근지정어 - 변수는 주로 노출방지 private
 *                       => 옵션 - static : 공통적인
 *                                final : 마지막, 상수
 *                                abstract : 추상적, 구현이 안된 (메소드에서 사용)
 *                                synchronized : 동기적 (메소드에서 사용)
 *                       - 인스턴스 변수 : 여러개를 동시에 저장 => new를 이용해서 생성, 메모리 공간 따로 생성 => Heap
 *                                     ex) 영화정보, 음악정보...
 *                       - 정적변수 static : 공통으로 사용되는 변수 => Method Area => 메모리공간 하나만 사용
 *                                         전체 데이터 목록 ex)사이트명...
 *                       ***대부분은 인스턴스 변수 사용
 *                       ***사용할 수 있는 변수 - 기본형, 배열, 클래스
 *                       ***클래스 안에서 변수가 없는 경우도 있다 (필요한 경우에만 사용)
 *                       ***변수 저장시 반드시 값을 필요로 한다 => 초기값
 *                          클래스 영역에 설정되는 멤버변수는 자동초기화
 *                          int 0 / long 0L / double 0.0 / boolean false / String null
 *                          => 프로그램에 따라 다른 초기값 필요할 수 있음
 *                             ex) int a=100; => 명시적인 초기화
 *                                 int a=난수발생, 파일읽기, 사용자 입력값...
 *                                       클래스 블록에서 사용불가 (선언만 가능, 구현불가)
 *                                       => 생성자, 초기화블록
 *                     생성자 선언
 *                       명시적 초기화가 안되는 경우 => 구현해서 값을 가지고 오는 경우
 *                       멤버변수 초기화
 *                       시작과 동시에 처리하는 명령문이 존재할 경우
 *                         ex)시작화면UI, 자동로그인, 서버연결, 서버가동, 데이터베이스 연결
 *                       없는경우 생략가능 - 프로그램 구동시에는 반드시 생성자 필요 => 컴파일러에 의해 자동추가(디폴트생성자-매개변수X)
 *                       특징 - 클래스명과 동일
 *                             리턴형이 없다
 *                             객체 생성시 호출 new 동반 new 생성자명()
 *                             여러개 생성자를 만들 수 있다 => 같은 이름의 메소드 제작 => 중복 메소드 정의 => 오버로딩**
 *                             └ 생성자 구분 => 매개변수로 구분(개수, 데이터형) => JVM이 알아서 데이터형에 맞게 찾아움
 *                             접근지정어,리턴형 관계없음
 *                       오버로딩
 *                         void display(int a, char c, double d)
 *                         void display(int a, double d, int b)
 *                         void display(double a, double b, double b)
 *                         void display(char a, int d, nt b)
 *                         
 *                         display(10.5, 'A', 10) => double char int
 *                         => void display(double a, double b, double b) 호출
 *                         => 해당 매개변수의 메소드가 없는 경우 가장 근접한 매개변수의 메소드 호출
 *                         
 *                         class A{
 *                            public void display(){}
 *                         }
 *                         A a=new A();
 *                         a.display();
 *                         ==
 *                         new A().display();
 *                       **생성자는 다른 클래스에 연결시 사용 => 접근지정어 public 사용
 *                       **객체지향 프로그램은 여러개의 클래스를 연결해서 제작
 *                     메소드 선언
 *                       인스턴스 메소드
 *                         public 리턴형 메소드명(매개변수목록){
 *                         
 *                         }
 *                         호출 ===> 객체명.메소드명
 *                       정적 메소드
 *                         public static 리턴형 메소드명(매개변수목록){ 
 *                         
 *                         }
 *                         호출 ===> 클래스명.메소드명
 *                       추상 메소드
 *                         public 리턴형 메소드명(매개변수목록){
 *                         
 *                         }
 *                         호출 불가능 => 구현 후에 사용
 *                       기능 구현 - 사용자 입력을 받는 경우(매개변수)
 *                                 요청처리에 대한 결과(리턴형)
 *                                 결과값 없을시 메소드 자체 처리(void)
 *                       ex) 기존 게시판기능 + 댓글 ==> 게시판 상속 => 기능 확장 => extends
 *                  }
 *	- 접근지정어 - private - 멤버변수
 *              public - 생성자, 클래스, 메소드 => 공개
 *
 *  
 */
public class 클래스_1 {
	/*
	static void display(char a) {
		System.out.println("char");
	}
	static void display(int a) {
		System.out.println("int");
	}
	*/
	static void display(double d) {
		System.out.println("display call...");
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//display(100); 
		//display('A');
		클래스_1 a=new 클래스_1();
		a.display(100);
		// == 위 아래 둘다 가능, 같은 의미 단, 아래코드가 객체 2개 생성
		new 클래스_1().display(100);
		new 클래스_1().display('A');
	}

}
