/*
 *	1.중복없는 난수 응용
 *	숫자 야구 게임
 *	1) 난수 3개 발생 3 6 9
 *	2) 사용자 입력 7 8 9
 *	3) 힌트 - 같은 자리 => S 1S
 *	         다른 자리 => B
 *	2-1) 사용자 입력 3 9 6
 *	3) 힌트 - 같은 자리 1S
 *	         다른 자리 2B 
 *	
 */

/*
 *	1.묶음
 *	  변수 여러개를 묶어서 관리
 *	  변수 여러개(평문) => 제어문 사용이 어렵다 => 배열(이름이 1개, 인덱스로 구분)
 *	  인덱스 0부터 순차적 => 반복문 돌리기 쉬움
 *	  **배열은 변수가 3개 이상일 경우 잡는다
 *	    => 3개이상이더라도 사용 용도가 같을 경우
 *
 *	  명령문 묶음 = 메소드
 *	  한개에 대한 정보 묶음 = 클래스
 *	  메소드 + 클래스 묶음 = 프로그램
 *
 *
 *    난수 100개 
 *    int a1=(int)(Math.random()*100)+1;
 *    ...
 *    int a100=(int)(Math.random()*100)+1;
 *    
 *    최대값/최소값
 *    int max=a1;
 *    if(max<a2)
 *       max=a2;
 *    ...
 *    if(max<a100)
 *       max=a100;
 *      
 *	=========================================
 *	 2장 연산자
 *		 종류
 *	      단항연산자 
 *	                   [], ()     연산방향 --->  1순위
 *	                 ++,--(전치연산)      <----  2순위
 *	                 ++,--(후치연산)      <----  3순위
 *                    !, (type)                3순위
 *          ex) (int)Math.random()*100
 *                   ------------------1순위
 *              -----2순위
 *          **(type) 형변환연산자
 *          숫자와 관련 / 클래스 - UpCasting => 데이터형을 크게 만든다(정수->실수 문자->정수)
 *          	            - DownCasting => 데이터형을 낮게 만든다(실수->정수 정수->문자)
 *          크기순서
 *                  ========= UpCasting =========>
 *             byte < char < int < long < float < double
 *                 <======== DownCasting =========
 *          ** 자동으로 변경 (자동 형변환)
 *             대입/연산
 *             int a='A' => a=65
 *             double d=10 => d=10.0
 *          ** 필요에 의해 강제 변경 (강제 형변환)
 *          변경되는 조건
 *            데이터형 변수명 = 값
 *            └ 값보다 큰 데이터형이여야 변경
 *              왼쪽이 큰 경우에는 자동 변환
 *              왼쪽이 작은 경우에는 강제 변환
 *              ** 필요에 의해 강제 변경 (강제형변환)
 *                 int a=10.5 => 오류 int < double ==> (int)double
 *                 ***예외
 *                    char c=65; *char는 예외
 *              ** 연산처리
 *                 1) char는 자동으로 int로 변경
 *                 2) 연산처리시에는 큰 데이터형으로 변경 후 연산처리(같은 데이터형이어야 함)
 *                    ex) 10+10.5 => 10.0+10.5
 *                        'A'+1 => 65+1
 *                 ** int이하 데이터형은 연산시에 int값의 결과가 나온다
 *                    char + char = int
 *                    byte + byte = int
 *                    ex) byte b1=10;
 *                        byte b2=20;
 *                        byte b3=b1+b2; ==> 오류
 *                        ----    ----- byte + byte = int
 *                    
 *                    int + int = int
 *                    double + double = double
 *              	
 *	      이항연산자
 *	        산술연산자    *, /, %  연산방향 --->  4순위
 *	                    +, -       --->     5순위
 *	                 ** + 산술외의 문자열 결합 연산자
 *	                   "7"+7 = "77"
 *	                   7+"7" = "77"
 *	                 ** / => 정수/정수=정수
 *	        비교연산자 <, >, <=, >=, ==, !=  연산방향 ---> 6순위
 *	                숫자, 문자, 논리 => 기본형 비교
 *	                equals() 문자열 비교
 *	                instanceof 클래스 비교
 *	                => 비교연산자의 모든 값은 true/false
 *	        논리연산자 &&   연산방향 --->  7순위
 *	                ||      --->      8순위
 *	                && => 범위 포함
 *	                      조건 2개가 동시에 true일 때만 true, 나머지 false
 *	                || => 범위를 벗어나는 경우
 *	                      조건 2개중에 1개 true면 true
 *	                if, for, while에서 사용
 *	        **우선 순위 모르는 경우 최우선순위연산자() 사용
 *	      삼항연산자 연산방향 <--- 9순위
 *	        조건?true:false == if~else
 *	        웹/게임에서 소스의 복잡도를 줄이기 위해 사용
 *	        ex) login?"로그아웃":"로그인"
 *	            ===>
 *	            if(login)
 *	              로그아웃
 *	            else
 *	              로그인
 *	      대입연산자 =, +=, -= 연산방향 <--- 10순위 => 가장 마지막에 처리되는 연산자
 *	        int a=10; => a라는 변수에 10을 대입한다(X)
 *	                     10을 a변수에 대입한다(O)
 *	        int a=10;
 *	        int b=20;
 *	        int c=a+b; ==> a+b 계산 후 c에 대입
 *
 *	     산술연산자 ==> 대입연산자
 *	     제어문 - 비교연산자, 증감연산자 (반복문) => 조건문 - 비교, 논리
 *	===========================================================자바 연산자
 *	3장 제어문 - 프로그램 제어
 *	           -반복 수행
 *	            for 반복횟수가 있는 경우 / 2차 for
 *	            while 반복횟수를 모르는 경우
 *	            do~while 반복횟수를 모르는 경우, 반드시 한번이상 수행
 *	           -건너뜀 - 단일조건문 if
 *	           -선택한 내용만 처리 - 다중조건문 if~else, 선택문 switch~case
 *             -오류처리 - 조건문 => 처리를 못하는 경우 예외처리 throws, try~catch
 *             	trows / try~catch - 반드시 예외 처리(8장), file관련, 네트워크, 다른 프로그램연결(네트워크, SQL)
 *             -반복문에 제어
 *             	종료 : break - 반복문, 선택문에서만 사용가능
 *              제외 : continue - 반복문에서만 사용가능
 *          - 조건문
 *              단일조건문
 *              - 제어문 형식
 *                  if(조건){ 조건이 true일 경우에 실행
 *                  	조건이 true일때만 수행
 *	                	false면 건너뜀             
 *                  }
 *              - 동작 순서
 *                  조건이 맞는 경우에만 실행
 *              - 사용 위치
 *                  오류처리 - 사용자 입력값을 받는 경우에 주로 처리
 *              - 조건 설정  
 *                  비교연산자/논리연산자(범위지정할 경우)
 *              **if를 여러개 사용하면 독립적이기 때문에 모든 조건 검색 => 여러문장 동시 수행 => 속도가 느려질 수 있다
 *	            **if~else = 선택조건문
 *	              true/false에 해당되는 소스코딩
 *	              if(조건문){
 *	                 조건 true일 때 처리
 *	              }else{
 *	                 조건 false일 때 처리
 *	              }
 *	              => 한줄 - 삼항연산자 ex) combobox, 페이지 지정...
 *	              => 두개로 나눠져 있는 경우 ex) 로그인, 아이디중복, 회원가입여부, 검색어 입력여부...
 *	                  웹 => true/false 모두 무조건 동작
 *              
 *              다중조건문 - 해당 조건문장만 수행 ex) 게임-키보드입력, 메뉴...
 *              - 형식 
 *                if(조건문){
 *                	조건문 true => 수행 => 종료
 *                }else if(조건문){
 *                	조건문 true => 수행 => 종료
 *                }else if(조건문){
 *                	조건문 true => 수행 => 종료
 *                }else{
 *                	해당 조건이 없는 경우에 처리 => 생략가능
 *                }
 *              - 선택문 => 다중조건문의 단순화
 *                switch(정수,문자,문자열){
 *                	case 1:
 *                		처리문장
 *                		break;
 *                	case 2:
 *                		처리문장
 *                		break;
 *                	case 3:
 *                	case 4:    => 처리문장이 같을 경우 case==3 || case==4 
 *                		처리문장
 *                		break;
 *                
 *                	...
 *                	default: 생략가능
 *                		처리문장
 *                }
 *	              => 웹에서는 사용빈도 적음
 *	              => 네트워크 경우의 수, 게임에서 사용
 *
 */
import java.util.Arrays;
import java.util.Scanner; //사용자입력
public class 중첩_for_6 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 1.컴퓨터가 난수 발생 1~9사이 중복없는 숫자 3개
		int[] com=new int[3];
		for(int i=0;i<com.length;i++) { // 3번 반복
			com[i]=(int)(Math.random()*9)+1;
			//중복 여부 확인
			for(int j=0;j<i;j++) {
				if(com[i]==com[j]) { //같은 수가 있는지 확인 비교연산/논리연산 
					i--; //다시 난수 발생
					break; // 2차 for문 종료 후 => 1차for문 증감식으로
				}
			}
		}
		System.out.println(Arrays.toString(com));
		
		// 사용자가 입력한 데이터 저장
		int[] user=new int[3];
		Scanner scan=new Scanner(System.in);
		
		// 2.사용자 입력요청 -> 입력 데이터 저장
		while(true) { //반복 횟수가 없다, 정답시 종료 => 무한루프
			System.out.print("세자리 정수를 입력하세요 >> ");
			int input=scan.nextInt();
			// 오류처리 => 세자리 정수가 입력되지 않은 경우
			if(input<100 || input>999) {
				System.out.println("알림 ☞ 세자리 정수만 입력해야 합니다");
				//while의 처음으로 이동
				continue;
				/*
				 *	continue
				 *	- while => 조건식으로 이동 => 재실행
				 *	- for => 증감식으로 이동 => 제외
				 * 
				 * 	break
				 * 	- while, for 상관없이 반복문 중단
				 * 
				 */
			}
			//사용자 입력 후
			user[0]=input/100;
			user[1]=(input%100)/10;
			user[2]=input%10;
			
			//오류처리
			//1. 같은 숫자가 있는지
			if(user[0]==user[1] ||
			   user[1]==user[2] ||
			   user[0]==user[2]) {
				System.out.println("알림 ☞ 중복된 수는 사용할 수 없습니다");
				continue; //다시입력
				//if 단일 조건문 => 사용자 입력 오류
			}
			//2. 0입력X(0이 앞에 붙으면 8진법)
			if(user[0]==0 || user[1]==0 || user[2]==0) {
				System.out.println("알림 ☞ 0을 사용하면 안됩니다");
				continue;
			}
			
			//정상적으로 입력이 되었다면
			// 3.비교 => 힌트
			int s=0,b=0; //s = 숫자와 자리수가 맞는 경우
			             //b = 숫자는 있고 자리수가 맞지 않는 경우
			for(int i=0;i<3;i++) { //com
				for(int j=0;j<3;j++) { //user
					if(com[i]==user[j]) { //같은 수가 존재하는지
						if(i==j) { //같은 수, 같은 자리
							s++;
						}else { //같은 수, 다른 자리
							b++;
						}
					}
				}
			}
			//힌트제공--
			System.out.printf("Input Number:%d,Result:%dS-%dB\n",input,s,b);
			
			// 4.정답여부 확인 정답=>종료(break)/오답=>다시입력(continue)
			// 종료 여부
			if(s==3) {
				System.out.println("Game Over");
				break;
			}
		}
		
		
		
		
		
		
	}

}
